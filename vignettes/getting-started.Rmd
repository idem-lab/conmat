---
title: "Getting Started"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting Started}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(conmat)
library(socialmixr)
library(ggplot2)
library(dplyr)
library(tidyr)
library(mgcv)
library(patchwork)
```

The goal of conmat is to make it easy to generate synthetic contact matrices for a given age population.

**What is a contact matrix?**

Contact matrices describe the degree of contact between individuals of given age groups. 

For example, this matrix describes the number of contacts between individuals

```{r}
#| label: show-contact
#| echo: FALSE

name_vec <- c("0-4", "5-9", "10-14")
cmat <- matrix(
  data = rep(NA, 9),
  nrow = 3,
  ncol = 3,
  byrow = TRUE,
  dimnames = list(
    name_vec,
    name_vec
    )
)

diag(cmat) <- c(10,11,13)
cmat[upper.tri(cmat)] <- 3:5
cmat[lower.tri(cmat)] <- 3:5

cmat
```

The rows and columns represent the age groups of the people. On the main diagonal we see that we have a higher number of contacts - showing that people of similar ages tend to interact more with one another.

We can use the information in these matrices to model how diseases such as COVID-19 spread in a population through social contact. 

**Why do we need _synthetic_ contact matrices?**

Contact matrices are produced from empirical data resulting from a contact survey, which requires individuals to diary the amount and manner of contact a person has in a day. 

However, these surveys are highly time-consuming and expensive to run, meaning that only a handful of these empirical datasets exist globally. 

We can use statistical methods to create _synthetic contact matrices_, which are new contact matrices that have been generalised to new countries based on existing surveys.

**Why do we need `conmat`?**

Existing methods only provide outputs of the contact matrices for each country, or at best, for urban and rural areas for a given country. 

We need methods that allow for flexibly creating synthetic contact matrices for a specified age population, as the age population distribution of many countries (e.g., Australia), are quite heterogeneous, and assuming it is homogeneous would result in inaccurate representation of community infection in many regions.

## Example

First we want to fit the model to the POLYMOD data, which contains various survey and population data.

```{r get-polymod}
library(conmat)
polymod_contact_data_home <- get_polymod_contact_data(setting = "home")
polymod_survey_data <- get_polymod_population()
```

The contact data is a data frame containing the age from and to, and the number of contacts for each of the specified settings, "home", "work", "school", "other", or "all" as well as the number of participants. By default, `polymod_contact_data` contains data from "all", but we're going to use the "work" set of data, as it produces an interesting looking dataset. Each row contains survey information of the number of contacts. Specifically, the number of contacts from one age group to another age group, and then the number of participants in that age group.

The survey data, `polymod_survey_data` contains the lower age limit and the population in that age group.

```{r show-polymod}
polymod_survey_data
```

We also provide control over the POLYMOD data retrieved from `get_polymod_contact_data()` via the arguments, `setting`, `country`, and `ages`. These allow you to specify the data to be only from certain settings or countries or ages. See `?get_polymod_contact_data` for more details. Below is a brief example of this:

```{r show-off-polymod-contact-data}
polymod_contact_data_belgium_0_10 <- get_polymod_contact_data(
  setting = "work",
  countries = "Belgium",
  ages = c(0,5,10)
)

polymod_contact_data_belgium_0_10
```

Similarly, you can control the population data, retrieving it only for certain countries:

```{r show-off-polymod}
get_polymod_population(countries = "Belgium")
get_polymod_population(countries = "Finland")
```

You can see the available countries in the helpfile with `?get_polymod_population`.

## Predicting the contact rate

We can create a model of the contact *rate* with the function `fit_single_contact_model`. We're first going to use some smaller sets of the data, to save on computation time.

```{r fit-polymod}
set.seed(2022-10-04)
polymod_contact_data_home_small <- polymod_contact_data_home %>% 
  filter(age_from <= 30,
         age_to <= 30)

polymod_survey_data_small <- polymod_survey_data %>% 
  filter(lower.age.limit <= 30)

contact_model <- fit_single_contact_model(
  contact_data = polymod_contact_data_home_small,
  population = polymod_survey_data_small
  )
```

This fits a generalised additive model (GAM), predicting the contact rate, based on a series of prediction terms that describe various features of the contact rates.

```{r show-conctact-model}
contact_model
```

We can use this contact model to then predict the contact rate in a new population.

As a demonstration, let's take an age population from a given LGA in Australia (this was the initial motivation for the package, so there are some helper functions for Australian specific data).

```{r fairfield}
fairfield_age_pop <- abs_age_lga("Fairfield (C)")
fairfield_age_pop
```

We can then pass the contact model through to `predict_contacts`, along with the fairfield age population data, and some age breaks that we want to predict to. Note that these age breaks could be any size, we just ahve them set to 5 year age brackets in most of the examples, but these could be 1 year, 2 year, or even sub year.

```{r predict-contacts}
set.seed(2022-10-04)
synthetic_contact_fairfield <- predict_contacts(
  model = contact_model,
  population = fairfield_age_pop,
  age_breaks = c(seq(0, 30, by = 5), Inf)
)

synthetic_contact_fairfield
```

## Plotting

Let's visualise the matrix to get a sense of the predictions with `autoplot`. First we need to transform the predictions to a matrix:

```{r plot-matrix-differents}
synthetic_contact_fairfield %>% 
  predictions_to_matrix() %>% 
  autoplot()
```

## Note 

It is worth noting that the contact matrices created using this package are transposed when compared to the contact matrices discussed by [Prem](https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1005697) and [Mossong](https://journals.plos.org/plosmedicine/article?id=10.1371/journal.pmed.0050074). That is, the rows are "age group to", and the columns are "age group from".

## Applying the model across all settings.

Our experience has been that we would be fitting the same models to each setting when doing data analysis when using conmat. Accordingly, you can also fit a model for all of the settings all at once with the functions, `fit_setting_contacts()`, and `predict_setting_contacts()`. This means we can do the above, but for each setting, "home", "work", "school", "other", and "all", at once. If we want to use all of the POLYMOD data, we can also use the `extrapolate_polymod()` function.

### Fit to all settings

We can create a model for each of the settings with `fit_setting_contacts()`.

```{r fit-polymod-setting}
set.seed(2021-09-24)

polymod_setting_data <- get_polymod_setting_data()

polymod_setting_data_small <- polymod_setting_data %>% 
  lapply(FUN = function(x) x %>% filter(age_from <= 20, age_to <= 20))

setting_models <- fit_setting_contacts(
  contact_data_list = polymod_setting_data_small,
  population = polymod_survey_data
  )
```

This contains a list of models, one for each setting. We can look at one, and get summary information out:

```{r names-setting-models}
names(setting_models)
setting_models$home
```

So this gives us our baseline model of a contact model. We have fit this model to the existing contact survey data. We can now predict to another age population, to create our "synthetic" contact matrix.

### Predict to all settings

Then we take the model we had earlier, and extrapolate to the fairfield data with `predict_setting_contacts`, also providing some age breaks we want to predict to

```{r fairfield-synth-5}
set.seed(2021-10-04)
synthetic_settings_5y_fairfield <- predict_setting_contacts(
  population = fairfield_age_pop,
  contact_model = setting_models,
  age_breaks = c(seq(0, 20, by = 5), Inf)
  )
```

This then returns a list of synthetic matrices, "home", "work", "school", "other", and "all", which is the sum of all matrices.

```{r str-synthetic-fairfield}
str(synthetic_settings_5y_fairfield)
synthetic_settings_5y_fairfield$home
synthetic_settings_5y_fairfield$all
```

We can use `autoplot` to plot all at once

```{r fairfield-synth-5-plot}
# this code is erroring for the moment - something to do with rendering a large plot I think.
autoplot(
  synthetic_settings_5y_fairfield,
  title = "Setting-specific synthetic contact matrices (fairfield 2020 projected)"
)
```


### Speeding up computation with `future`

`conmat` supports parallelisation, which is useful in a couple of contexts with the model fitting, here is an example:

```{r load-future}
library(future)
plan(multisession, workers = 4)
```

We set the future plan, saying "multisession", with 4 workers. Then we run the same code as above (note that you must specify the plan, otherwise it does not know how to parallelise. See the [future package documentation](https://future.futureverse.org/reference/plan.html) for more details):

```{r show-off-furrr}
contact_model <- fit_setting_contacts(
  contact_data_list = polymod_setting_data_small,
  population = polymod_survey_data_small
)

contact_model_pred <- predict_setting_contacts(
  population = polymod_survey_data_small,
  contact_model = contact_model,
  age_breaks = c(seq(0, 20, by = 5), Inf)
)
```

Notably this is about 3 times faster than without using that plan.

### Extrapolate from all POLYMOD data

The above model fitting and prediction steps are all done on the full POLYMOD data. But you could modify the polymod data used in the model, to say be only for Finland, or Germany, or a specific age group.

However, if you want to predict to all settings, using the full POLYMOD data, to a specific new age population, you can use `extrapolate_polymod`, which takes arguments for a new population, age breaks, and optionally household per capita size. By default it uses 5 year age breaks from 0-75, then 75 and above.

We can demonstrate fitting a model using just Fairfield data, like so:

```{r}
# compute setting-specific and combined age matrices for polymod
synthetic_settings_5y_fairfield <- extrapolate_polymod(
  population = fairfield_age_pop
)

autoplot(synthetic_settings_5y_fairfield)
```

We can also do the same, for the polymod data itself:

```{r}
# compute setting-specific and combined age matrices for polymod
polymod_population <- get_polymod_population()
synthetic_settings_5y_polymod <- extrapolate_polymod(
  population = polymod_population
)

autoplot(synthetic_settings_5y_polymod)
```

And for fun we can compare some of the data together, say polymod data for home against fairfield home, using the `patchwork` package:

```{r}
library(patchwork)
gg_polymod_home <- autoplot(synthetic_settings_5y_polymod$home) + 
  labs(title = "polymod home")

gg_fairfield_home <- autoplot(synthetic_settings_5y_fairfield$home) + 
  labs(title = "Fairfield home")

gg_polymod_home + gg_fairfield_home
```

This might not look that different, but we can compare this to Alice Springs

```{r}
synthetic_settings_5y_alice <- extrapolate_polymod(
  population = abs_age_lga("Alice Springs (T)")
)

gg_alice_home <- autoplot(synthetic_settings_5y_alice$home) + 
  labs(title = "Alice Springs home")

gg_polymod_home + gg_alice_home
gg_polymod_home + gg_fairfield_home
```

We can use some other functions from `socialmixr` to extract similar estimates for different populations in different countries.

```{r}
library(socialmixr)

italy_2005 <- wpp_age("Italy", "2005")

italy_2005
```

This italian population data could then be put into `extrapolate_polymod` as above.

## For interest's sake: visualising the empirical contact rate data

```{r}
# visualise empirical contact rate estimates
bind_rows(
  home = get_polymod_contact_data("home"),
  school = get_polymod_contact_data("school"),
  work = get_polymod_contact_data("work"),
  other = get_polymod_contact_data("other"),
  .id = "setting"
) %>%
  mutate(
    rate = contacts / participants,
    setting = factor(
      setting,
      levels = c(
        "home", "school", "work", "other"
      )
    )
  ) %>%
  group_by(
    setting
  ) %>%
  mutate(
    `relative contact rate` = rate / max(rate)
  ) %>%
  ungroup() %>%
  ggplot(
    aes(
      x = age_from,
      y = age_to,
      fill = `relative contact rate`
    )
  ) +
  facet_wrap(
    ~ setting,
    ncol = 2,
    scales = "free"
  ) +
  geom_tile() +
  scale_fill_distiller(
    direction = 1,
    trans = "sqrt"
  ) +
  theme_minimal()
```

