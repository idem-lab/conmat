---
title: "Code documentation"
author: "Vignette Author"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(conmat)
library(tidyverse)
```

## About conmat

We want to understand the spread of infectious diseases in a population. One approach to this is to use contact matrices. These give the number of expected contacts from one age group to another. For example, there might be a lot of contact between infants (ages 0-5) and parents (ages 25-45), and grandparents (age 55+) but not as much contact between teenagers (age 11 - 19) and infants.

The amount of contact also changes depending on the settings, such as home, school, and work. At work, age groups of ages 20 - 50, will have more contact with each other, and less / little contact with people aged 70+, and below the age of 20, as the number of people in those workforces is smaller.

We have information, based on special surveys, which show the number of people who have contact with each other, in different settings, such as work, home, school, and other. These surveys have been conducted in different places in the world. Specifically, we have information on the amount of contact from a "polymod" survey, which surveyed the following countries:

-   Italy, Germany, Luxembourg, Netherlands ,Poland, United Kingdom, Finland, and Belgium

However, this is only a small number of countries in the world! We could generalise this to other countries, but they will differ in a variety of ways. These can be hard to measure and adjust for. For example, it is very common in Singapore for the elderly to live with their family, and so there will be more contact between the elderly and their children and grand children. This is less common is places like Australia, and the USA. And even within countries this can vary greatly. For example, looking at the age population structure of Alice Springs, compared to Sydney, we can see that they are very different.

```{r}
#| label: figure-pyramid
#| echo: FALSE
data_age_transform <-  bind_rows(
  abs_age_lga("Sydney (C)"),
  abs_age_lga("Alice Springs (T)")
) %>% 
  group_by(lga) %>%
  mutate(
    age_multiplier = cur_group_id(),
    age_multiplier = if_else(age_multiplier == 2,
                             1,
                             -1),
    .after = lga
  ) %>%
  mutate(population_per_capita = population / sum(population)) %>% 
  ungroup() %>%
  mutate(age = as_factor(lower.age.limit),
         population = (population * age_multiplier),
         population_per_capita = (population_per_capita * age_multiplier))
pretty_symmetric <- function(range, n = 5){
  range_1 <- c(-range[1], range[2])
  range_2 <- c(range[1], -range[2])
  
  pretty_vec_1 <- pretty(range_1)
  pretty_vec_2 <- pretty(range_2)
  
  pretty(
    c(pretty_vec_1, pretty_vec_2), 
    n = n
  )
  
}
  
  # round to nearest 10
  pop_range <- range(data_age_transform$population_per_capita)
  
  age_range_seq <- pretty_symmetric(pop_range, n = 5)
  
  
   ggplot(data_age_transform,
         aes(x = population_per_capita,
             y = age,
             fill = lga)) +
    geom_col() +
    scale_x_continuous(breaks  = age_range_seq,
                       labels = abs(age_range_seq)) +
    expand_limits(x = range(age_range_seq)) + 
    scale_fill_brewer(palette = "Dark2",
                      guide = guide_legend(
                        title = ""
                      )) +
    theme_minimal() +
    theme(legend.position = "top")
```

If we assume the same amount of contact between Sydney and Alice Springs, based on the information that we have from a countries like Germany, or the UK, then we are ignoring the very heterogeneous population information of Australia. We would be saying that both Alice Springs, and Sydney have the same population structure. This would lead to very different estimates of the amount of contact between age groups.

So how do we correct for this difference in ages? Although it would be best to conduct separate surveys in each country, and within each part of a country, these surveys are expensive, and time consuming.

One way to adjust the contact surveys, is to use information on the age population of a given place. We can then use this information to appropriately increase or decrease the amount of contact between certain age groups.

As a simple example, if we find that Sydney has 4 times the number of 20-25 year olds, compared to the UK, then we might increase the estimate of the contacts between 20-25 year olds by 4.

## How do we use conmat?

Due to the lack of data from contact surveys in the majority of countries in the world, we need to use specialised techniques to project or extrapolate contact rates. conmat uses a different approach to previous methods, employing a generalised additive model (GAM) to project or extrapolate the POLYMOD data and to predict contact rates for any age groups and obtain the age and location specific contact patterns present in the local government areas or states.

## What is a contact matrix?

The risk of transmission between two individuals could be proportional to the amount or frequency of contact between them, therefore contact patterns play a tremendous role in decoding the transmission dynamics of an infectious disease and as well as employing effective public health safeguards such as imposing school closures or lockdown measures. These contact patterns can vary across different ages as well as different locations of interaction. One way to express these patterns are in matrices, in which each element indicates the estimated number of contacts between subgroups, such as age groups, which are represented as rows and columns. The location of interactions can also be taken into account by generating these contact matrices at different settings such as workplace, home, school and so on. For example, age based contact matrix at a school allow us to determine the average number of contacts an individual in age group, A, has with another individual of the same age group or another age group, B, at the location, school.

\

![](https://lh4.googleusercontent.com/cL3q-2uVrY4jwXOXsWpQilQf1EkTadtHKs0iGD73Gw7Xi6f3xXLTrkuCgiBFy0pafidd3G_FsKRuyeRAWc2Z4SUyXJF2SKbVAh8vmhVUML0e-giiLa8dDwm6Eqekt4Vc-SGS-_MSqDVswcaH7hSufQ){width="414"}

\
**- [ ] Why are contact matrices used? Are there alternatives?**

Can include discussion on alternative names - e.g., mixing matrices. Mossong et al., also discuss that sometimes instead of contact matrices they infer contacts through indirect observations, and were assumed to follow patterns, which were calibrated against data such as serological (lab tests - where they can tell who has been in contact with who based on the similarity of the virus DNA (I think...)), or case notification data (NOTE: I'm not really sure how they infer contact information this, do they infer that certain people visited the same place at around the same time, or do people provide information on who they have contacted recently?).

You can also simulate disease spread without contact matrices, and make different assumptions based on how disease might spread - e.g., an agent based model might have different base assumptions on how people spread COVID.

As stated in Mossong paper:

> Until now, modellers have relied on proxy measures of contacts and calibration to epidemiological data. For instance, household size, class size, transport statistics, and workplace size distribution have been used in recent models to deï¬ne the contact structure [2,3,33,34].\

**[ ] What is a contact survey?**

\
Contact surveys track the number of contacts between individuals, as well as the nature (physical or non-physical, duration of contact etc.) and location of those contacts along with the survey respondent's socio demographic characteristics, such as work status, household size, age, and so on. One such survey is the POLYMOD contact pattern study which utilises respondent filed social contact diaries from 8 European countries: Belgium, Germany, Finland, Great Britain, Italy, Luxembourg, The Netherlands and Poland in an attempt to quantify social mixing patterns. Conmat retrieves the POLYMOD survey data primarily through two functions, \`get_polymod_setting_data()\` & \`get_polymod_population()\`.

## Helper Functions

#### abbreviate_states

-   produces the abbreviation of the state names in Australia. DONE

#### unabbreviate_states

-   produces the full names of states in Australia from its abbreviations. DONE

#### age_group_lookup

- A lookup table for the age groups in 5 year bins that a particular age belong to. The dataset contains three variables: age group, its lower and upper limit. DONE

#### separate_age_group

- An internal function used within `check_args_age_population_year()` to separate age groups in a data set into two variables for the lower and upper age limit. DONE

#### check_args_age_population_year

- Internally used function within `age_population()` to separate age groups into its lower & upper limit and to filter the data passed to the desired year and location.
- renamed to `clean_age_population_year` DONE


#### age_population_year

DONE
- The function helps clean up data sets of population data,  similar to `socialmixr::wpp_age()` or any given data set with a structure that has information on, population, location, age or age groups, and year into a format that has information on the upper and lower limit of the age groups. It accepts a data set with variables age, country,year and the corresponding population, as an argument and checks the data type of the variable representing age. If it's numeric, the function proceeds to an additional stage of grouping ages into age groups with 5 year bins. The function uses `check_args_age_population_year()` to separate age groups into its lower & upper limit and to filter the data passed to the desired year and location. 

#### bin_widths

DONE
-   Internal function that takes in a numeric vector and return the differences between the values in the vector assuming the final value is the same as the penultimate value.

#### check_lga_name & check_state_name
DONE
-   Function, primarly used internally checks if the LGA/state name exists in Australia and errors if not valid.



### Data

#### abs_age_lga & abs_age_state
DONE
-   Uses the data sourced from ABS on the state and LGA wise population for different age groups for the year 2020.

-   The function first checks if the LGA/state name exists in Australia and later filters out the given LGA/ State and produces the lower limit of age group and the corresponding population in the region for the year 2020.

#### abs_education_state_2020
DONE
A data set containing the Australian Bureau of Statistics education data by state for 2020 which was interpolated into 1 year age bins.



```{r}
abs_education_state_2020
```


> Are we using this dataset in conmat? Unsure - but we should leave it here
at the moment

#### data_abs_education_state
DONE
A data set containing the Australian Bureau of Statistics education data by state for years 2006 to 2020. 

> Use case? example in get_age_population_function

```{r}
abs_education_state
```

#### abs_employ_age_lga
done
> Use case? 

A data set containing the Australian Bureau of Statistics employment data by state for the year 2016

```{r}
abs_employ_age_lga

```

>use case?

#### data_abs_household_lga
DONE
A data set containing state and LGA wise data from Australian Bureau of Statistics for the year 2016 which has information on the number of people typically in a residence in the region and the number of households associated with those number of residents. This data set is typically used to obtain the household size distributions to compute the per capita household size of a particular region. 

The data frame has the following variables :

  - year : depicts the year the census was taken
  - state : Abbreviated Australian state name
  - lga : Local government area 
  - n_persons_usually_resident : Number of people who are in residence
  - n_households : Number of households with the associated number of residents
  
```{r}
abs_household_lga
```


#### data_abs_lga_education
DONE
#### data_abs_lga_work
DONE
#### data_abs_state_age
DONE
#### data_abs_state_education
DONE

#### data_abs_state_work
DONE
#### data_eyre_transmission_probabilities
DONE
#### get_data_abs_age_education
DONE
#### get_data_abs_age_work
DONE



#### get_polymod_population
DONE
-   uses the participant data from the polymod survey as well as the age specific population data from socialmixr r package to return the age specific average population of different countries weighted by the number of participants from those countries who participated in the polymod survey.

#### get_polymod_contact_data
DONE
-   uses the contact and participant data on the desired countries from the survey and impute the missing contact ages primarily through either of the three methods such as imputation of contact ages from a uniform distribution or using the average of the ages or through removal of those participants.

-   The contact settings are then classified as "home", "school", "work" and "others" where "others" include locations such as leisure, transport or other places.

-   The participants with missing contact ages or settings are removed and the number of contacts per participant and contact age from ages 0-100 are obtained for various countries and settings.

#### get_polymod_setting_data
DONE
-   get_polymod_setting_data acts as an extension of **get_polymod_contact_data** and extracts the setting wise contact data on the desired country as a list.

### Other Important stuff

#### adjust_household_contact_matrix

-   Used primarily inside the \`predict_setting_contacts()\` function.

-   Uses the polymod per capita household size to adjust the number of household contact in the given list of 4 setting-specific synthetic contact matrices, to match the average household size in that region from the Australian Bureau of Statistics data.

-   To do so, the function calculates the ratio between expected number of other household members for the desired region from ABS data (obtained by subtracting 1 from the household size), and the average per capita household size obtained from the polymod data which was used to train the model. This ratio is then multiplied to the "home" setting which then is reflected on to "all" settings, thereby forming a new set of setting-specific synthetic contact matrices.

-   The function uses \`abs_household_data\`, lga & state level data on the household size (1 to 8 ) and the number of households with that particular household size, obtained from Australian Bureau of Statistics.

-   Depending on the region level that is nation wide , state or lga , the number of people in a household of a particular household size is calculated by multiplying the number of households of a size with the household size, thus producing the household size distributions of a particular region.

-   It returns a dataframe with columns: year, state, lga, household_size, and n_people. So a given row represents the number of people with that household size.

-   So running this for a given LGA returns a dataframe of the number of people in a given household size:

```{r}
hh_size_fairfield <- get_household_size_distribution(lga = "Fairfield (C)")
hh_size_fairfield
```

-   And running it for a given state returns each LGA for each state - so you will still need to summarise this to get it at the state level. NOTE: Shouldn't it just collapse across state without LGA info?

```{r}
get_household_size_distribution(state = "NSW")
```

> Note : Why group by state inside the switch() ? - I think we can leave this as is. 

### per_capita_household_size
DONE
-   Uses the household size distributions on relevant state or LGA using the \`get_household_size_distribution()\` which has information on the number of people in the region with household sizes from 1 to 8 - e.g. we can use the household size distribution for Fairfield from before:

```{r}
hh_size_fairfield
```

-   Using the household size distributions , the fraction of population with a particular household size is obtained and multiplied with the household size to later produce the population-weighted average of household sizes or per capita household size.

```{r}
per_capita_household_size(
  household_data = hh_size_fairfield,
  household_size_col = household_size,
  n_people_col = n_people
)
```

NOTE - check this: This household size per capita information can then be used to adjust estimates when say calculating the next generation matrix.

### Model fitting

#### get_age_population_function
DONE
> Returns an interpolating function to get populations in 1y age increments. - The purpose of the function is to return a function that takes in a numeric vector and returns the interpolated population corresponding to the ages passed. For example, you can pass in an example population with the following structure - with a lower.age.limit and population column.

```{r}
example_pop <- get_polymod_population()
example_pop
```

But these ages and populations are binned every 5 years. So we can now provide a specified age and get the estimated population for that 1 year age group. First we create the new function like so

```{r}
# get function to interpolate population age distributions to 1y bins
age_population_function <- get_age_population_function(example_pop)
```

Then we can pass it a given year, or vector of years:

```{r}
age_population_function(age = 0)
age_population_function(age = 5)
sum(age_population_function(age = 0:4))
```

Notice that we get a pretty similar number of 0-4 if we sum it up, as the first row of the table:

```{r}
head(example_pop, 1)
sum(age_population_function(age = 0:4))
```

-   The function first prepares the data to fit a smoothing spline to the data for ages below the maximum age. It takes the data, arranges the lower limit of the age group to obtain the bin width/differences of the lower age limits. The mid point of the bin width is later added to the ages and the population is scaled as per the bin widths.

-   The maximum age is later obtained and the populations for different above and below are filtered out along with the sum of populations with and without maximum age.

-   A cubic smoothing spline is then fitted to the data for ages below the maximum with predictor variable as the ages with the mid point of the bins added to it where as the response variable is the log-scaled population.

-   Using the smoothing spline fit, the predicted population of ages 0 to 200 is obtained and the predicted population is adjusted further using a ratio of the sum of the population across all ages from the data and predicted population. The ratio is based on whether the ages are under the maximum age as the total population across all ages differs for ages above and below the maximum age. The maximum age population is adjusted further to drop off smoothly, based on the weights.

-   The final population is then linearly extrapolated over years past the upper bound from the data. For ages above the maximum age from data, the population is calculated as a weighted population of the maximum age that depends on the years past the upper bound. Older ages would have lower weights, therefore lower population.

#### add_modelling_features
DONE
> Features like population distribution of contact ages, school work participation as well as the offset is added on to the data using this function - The function takes the contact data which has information on the participants' age, contact ages, number of participants in that age group as well as the number of contacts the pair of individuals in the particular age group have. For example, below shown is the contact data in the setting "home"

```{r}
polymod_contact_data <- get_polymod_setting_data()
polymod_contact_data$home
```

-   The modelling features like the population distribution of contact ages, fraction of population in each age group that attend school/work as well as the offset according to the settings are added on to the contact data through three internal functions shown below.

##### add_population_age_to
DONE
> use interpolated population of "age_to" (contact age) & get the relative population grouped by "age_from" or participant age. - Function uses the `get_population_function()` to add the interpolated population for different contact ages based on the population data on the region provided, through which the population distribution of contact ages is obtained.

##### add_school_work_participation
DONE
-   This function adds new variables for:
    -   school & work attending fraction for contact & participant ages
    -   probability that a person of the other age goes to the same work/school
    -   probability that a person of the other age would be in the same school year
    -   weighted combination of contact population age distribution & school year probability so that if the contact is in the same school year, the weight is 1, and otherwise it is the population age fraction. This can be used as an offset, so that population age distribution can be used outside the classroom, but does not affect classroom contacts (which due to cohorting and regularised class sizes are unlikely to depend on the population age distribution).

##### add_offset
DONE
-   Function defines the offset variable for the model to be fitted in \`fit_single_contact_model()\`.

-   Sets separate offset for school setting when compared to the other settings such as home, work and other.

-   log(population) for settings : home, work and other. The offset for school captures cohorting of students for schools and takes the logarithm of the weighted combination of contact population age distribution & school year probability calculated in the `add_school_work_participation()`.

-   The choice of the offset is set in the model formula.

```{r, eval=FALSE,echo=TRUE}
offset_variable <- switch(
    setting,
    school = "log_contactable_population_school",
    "log_contactable_population"
  )
```

> why double offsets? : The offsets get added together when the model first fit. In addition, the setting specific offset from `offset_variable`, which is included in the GAM model as `... + offset(log_contactable_population)` is used in prediction, whereas the other offset, included as an argument in the GAM as `offset = log(participants)` is only included when the model is initially created. 

#### fit_single_contact_model
DONE
-   This is the workhorse of the conmat R package. It predicts the contact rate between all age bands (the contact rate between ages 0 and 1, 0 and 2, 0 and 3, and so on), for a specified setting, with specific terms being added for given settings.
-   The model fit is a Generalised Additive Model (GAM). To help account for assortativity with age, where people of similar ages have more contact with each other, we include predictors `age_from`, and `age_to`. To account for intergenerational contact patterns, where parents and grandparents will interact with their children and grand children, we include a term that is the absolute difference of age_from and age_to. We also include the interaction of intergenerational contact patterns with contacts from one age with the term that is the absolute difference of age_from and age_to, and age_from. These terms are fit with a smoothing function. Specifically, the relevant code looks like this:

``` r
s(age_to) + 
  s(age_from) + 
  s(abs(age_from - age_to)) + 
  s(abs(age_from - age_to), age_from)
```

-   We also include predictors for the probability of attending school, and attending work. These are computed as the probability that a person goes to the same school/work, proportional to the increase in contacts due to attendance. These terms are calculated from estimated proportion of people in age groups attending school and work.

-   Finally, we include two offset terms so that we estimate the contact rate, that is the contacts per capita, instead of the number of contacts. These offset terms are the `log(contactable_population)`, and `log(contactable_population_school)` when the model is fit to a school setting. The contactable population is estimated as the interpolated 1 year ages from the data. For schools this is the contactable population weighted by the proportion of the population attending school.

-   This leaves us with a model that looks like so:

``` r
 mgcv::bam(
  formula = contacts ~
    s(age_to) +
    s(age_from) +
    s(abs(age_from - age_to)) +
    s(abs(age_from - age_to), age_from) +
    school_probability +
    work_probability + 
    offset(log_contactable_population) +
    # or for school settings
    # offset(log_contactable_population_school) 
  family = stats::poisson,
  offset = log(participants),
  data = population_data
    )
```

#### fit_setting_contacts
DONE
-   fit_setting_contacts acts as an extension of fit_single_contact_model

-   fits a gam model for each setting on the survey population data & the setting wise contact data.

-   Returns a list of fitted gam models for each setting.

> fit_setting_contacts is used to fit the contact model to the polymod data which includes the setting wise polymod contact data from `get_polymod_setting_data()` and the polymod population data from `get_polymod_population()`. The model is then used to extrapolate to the data on the desired LGA/state using the `predict_setting_contacts()`.

#####  polymod_setting_models
DONE
For convenience, the list of fitted gam models predicting the number of contacts in each of the four settings, "home","work","school" and "other" using the polymod data is stored in conmat as a data object named `polymod_setting_models`

#### predict_contacts
DONE
> `predict_contacts()` predicts the contact rate between two age populations, given some setting-specific model of contact rate and population age structure. It takes three arguments: 1) model: A single fitted model of contact rate (say from `fit_single_contact_model()`), 2) population: a dataframe of age population information, with columns indicating some lower age limit, and population, and 3), age breaks - the ages to predict to. By default, the age breaks are O-75 in 5 year groups.

As an example, if we have a model of contact rate at home, and age population structure for an LGA, say, Fairfield, in NSW:

```{r}
polymod_setting_models$home

fairfield_abs_data <- abs_age_lga("Fairfield (C)")

fairfield_abs_data
```

Then we can predict the contact rate for Fairfield from the existing contact data, say, between the age groups of 0-15 in 5 year bins for school, like so:

```{r}
fairfield_school_contacts <- predict_contacts(
  model = polymod_setting_models$school,
  population = fairfield_abs_data,
  age_breaks = c(0, 5, 10, 15,Inf)
)

fairfield_school_contacts
```

Implementation details

-   This function, `predict_contacts` is used internally inside `predict_setting_contacts()`, which predicts for all settings (home, work, school, other) the expected contact rate for a given population age structure, and also optionally performs an adjustment for per capita household size. You can use `predict_contacts()` yourself, just be aware you will need to separately apply a per capita household size adjustment if you want to use that. See `adjust_household_contact_matrix` for more details.

-   The population data is used to determine age range to predict contact rates, and removes ages with zero population, so we do not make predictions for ages with zero populations.

-   Contact rates are predicted yearly between the age groups, using `predict_contact_1y()`, then aggregates these predicted contacts using `aggregate_predicted_contacts()`, which aggregates the predictions back to the same resolution as the data, appropriately weighting the contact rate by the population.

##### predict_contacts_1y
DONE
> Primary purpose of `predict_contacts_1y` is to use an already fitted model of contact rate and predict the estiamted contact rate and standard error for all combinations of the provided ages in 1 year increments. So if the minimum age is 5, and the maximum age is 10, then it will provide the estimated contact rate for all age combinations: 5 and 5, 5 and 6 ... 5 and 10, and so on.

- This function is used internally within `predict_contacts()`.  

- It takes four arguments: 1) model - the fitted statistical model of contact rate, 2) population - data with age and population information. It also takes 3) age_min, and 4) age_max arguments, which are used to specify the age range which will then be specified in years


-   Takes in the fitted model, population data of the region to be extrapolated on as well as the minimum and maximum ages as arguments.

-   Prediction features to make predictions on the desired population are then added using the `add_modelling_features()`. These features include the population distribution of contact ages, fraction of population in each age group that attend school/work as well as the offset according to the settings on all combinations of the participant & contact ages.

-   Uses `predict()` to make predictions as well as add the measure of uncertainty or standard error of predicted means, based on the fitted model and the data passed after adding the prediction features.

-   Returns a data frame with all combinations of participant & contact ages from the minimum and maximum ages provided along with the predicted number of contacts and the level of uncertainty. For example,

```{r}
predict_contacts_1y(
  model = polymod_setting_models$home,
  population = fairfield_abs_data,
  age_min = 0,
  age_max = 2
)
```

##### aggregate_predicted_contacts
DONE
> Obtains the population weighted average contacts a particular age group has with another age group at a particular setting. These age groups are decided according to the age breaks passed through the function as arguments.

-   Used internally within `predict_contacts()`.

-   Uses the output from `predict_contacts_1y()` that is the predicted number of contacts for all combinations of participant & contact ages, to obtain the total number of predicted contacts each participant of a particular age has with a specific age group. This is then used to calculate average of the number of contacts the participant age group has with a specified age bracket, weighted by the population distribution of the participant age.

-   Returns a data frame with all combinations of participant & contact age groups and the population weighted average number of contacts between each age groups. For example,

```{r}

fairfield_school_contacts
```

#### predict_setting_contacts
DONE
-   Predicts contact rates for all combinations of age groups specified by the desired age breaks, in a desired population across settings such as "home","school", "work", "other" and the combination of all settings.

-   These predictions are then converted to matrix format using `predictions_to_matrix()` to produce contact matrices for all age groups combinations across different settings or location of contact.

-   Upon obtaining the contact matrices, the household contact matrix is consequently adjusted by the per capita household size of the region for which the predictions are made if provided , in order to in order to upweight larger household size. See `adjust_household_contact_matrix()` for more info.

##### predictions_to_matrix
DONE
-   Helper function to convert predictions of contact rates in data frames to matrix format with the survey participant age groups as columns and contact age groups as rows.

##### matrix_to_predictions
DONE
-   Helper function to convert contact matrices to data frame format.

#### extrapolate_polymod
DONE
> Allows to fit all-of-polymod model and extrapolate to a given population and age breaks with optional adjustment to the household contact matrix.

-   Uses `estimate_setting_contacts()` to fit a contact model on the data from polymod and later extrapolate on to a desired population.

##### estimate_setting_contacts
DONE
-   Utilises the inbuilt `fit_setting_contacts()` & polymod survey contact & population data to fit a contact model on the polymod data and extrapolate the fitted model to a desired population and age breaks using the `predict_setting_contacts()`. The predicted household contact matrix can also be adjusted optionally by the region's per-capita household size.

### Plotting

#### plot_matrix
DONE
> The predicted contact rates in the form of contact matrix are best analysed through visualisations. This enables to undertsand the underlying patterns and relationships between age groups in different settings of contact such as workplace, home, school and others.

Conmat uses `plot_matrix()` to visualise these contact matrices. The function accepts contact matrix as an argument, converts it to a data frame format and subsequently plots it with the x and y axes being different age groups.

The figure below displays the projected contact rates for "home" in the region of Fairfield, in 2020. The graph shows that similar age groups typically have higher rates of home contact. Indicators of parental links include middle-aged age groups having observable contact rates with younger age groups. For instance, ages between 25 and 45 have higher contact rates with newborns (0 to 5) and children (5 to 10), but older age groups, including those over 55, tend to have higher contact rates with age groups between 25 and 45, showing the interactions between parents and children. In addition to this, other patterns that indicates contact between children and their grandparents where higher contact rates between young children (years 0-5) and grandparents (age 55+) are present. 

```{r}
plot_matrix(synthetic_settings_5y_fairfield_hh$home)+
  ggtitle("Synthetic contact matrices for home setting (fairfield 2020 projected)")
```

#### plot_setting_matrices
DONE
plot_setting_matrices acts as an extension of plot_matrix where the contact matrix for each setting is visualized as shown below,

```{r}
plot_setting_matrices(
  synthetic_settings_5y_fairfield_hh,
  title = "Setting-specific synthetic contact matrices (fairfield 2020 projected)"
)
```

### Transmission Matrices
( DONE moved to "example pipeline" vignette)
The initial phase of COVID-19 pandemic saw a significant age dependence in the distribution of confirmed cases with fewer confirmed cases among children. This might have been a result of younger ages being less susceptible to infection and/or less likely to exhibit clinical signs when infected [ [Davies et al](https://www.nature.com/articles/s41591-020-0962-9)] . A population's clinical fraction and age-varying susceptibility to infection both profoundly influence the likelihood that an infectious agent would spread there. This likelihood that an infectious agent would spread from an infected source to a new susceptible host and infect the host is known as transmission probability.

The age and setting specific relative per-contact transmission probability matrices when combined with contact matrices could be used to produce the setting-specific relative next generation matrices (NGMs) which is used to obtain the distribution of numbers of new cases in each generation of infection from any arbitrary initial number of introduced infections. Conmat creates these age and setting specific relative per-contact transmission probability matrices through `get_setting_transmission_matrices()` by making use of clinical fraction and relative susceptibility parameters from Davies et al available through `davies_age_extended`. 

##### davies_age_extended
DONE
The clinical fraction and relative susceptibility parameters from Davies et al are presented in conmat through the dataset named \`davies_age_extended\` which has the following variables ,

-  `age` : Ages from 0-101

-   `clinical_fraction` : An estimate of clinical fraction or the age-specific proportion of infections resulting in clinical symptoms inferred by applying a smoothing spline to the mean estimates from Davies et al.

-   `davies_original` : Age specific parameters of the relative susceptibility to infection inferred from a smoothing-spline estimate of the mean relative susceptibility estimate from Davies et al.

-   **`davies_updated` ? : Re-estimated parameter of the susceptibility profile for under-16s that is estimated in a similar way but to the age-distribution of infections in England from the UK ONS prevalence survey rather than case counts which may undercount children ?** 

#### get_setting_transmission_matrices
DONE
> Given some user specified age breaks, `get_setting_transmission_matrices` returns a named list of matrices containing age-specific relative per-contact transmission probability matrices for each of 4 settings: home, school, work, and other. It accounts for vaccination, reduced mixing, and reduced transmissibility in work and other settings due to hygiene behaviour. 

It takes three arguments : 

- Age breaks

- Asymptomatic relative infectiousness. This represents the infectiousness of asymptomatic relative to symptomatic. Default value is 0.5. So the asymptomatic cases are 50% less infectious than symptomatic cases.

- The Davies et al age specific susceptibility parameter estimates, currently either: `davies_original` or `davies_updated`.

We obtain the age specific estimate of infectiousness for all age combinations. To do this we use the age dependent clinical fraction from the R object, `davies_age_extended`, and the assumed relative infectiousness of asymptomatics to symptomatics.

```{r}
age_breaks <-  c(seq(0, 80, by = 5), Inf)
asymptomatic_relative_infectiousness <- 0.5
age_effects <- davies_age_extended %>%
    dplyr::mutate(
      infectiousness = clinical_fraction + (1 - clinical_fraction) *
        asymptomatic_relative_infectiousness
    ) %>%
    dplyr::select(
      age,
      infectiousness,
     davies_updated
    )
age_effects
```

We also obtain age specific susceptibility estimates, by taking all combinations of ages and joining the infectiousness and davies updated estimates, averaging across settings (home, work etc) and age groups such as 0-5,5-10 and so on, as per the specified age breaks.

```{r}
setting_weights_tibble <- tibble::tibble(setting = names(setting_weights),
                                         weight = setting_weights)

agg_infectiousness_suscpetibility <- tidyr::expand_grid(
  setting = setting_weights_tibble$setting,
  age_from = age_effects$age,
  age_to = age_effects$age
) %>%
  dplyr::left_join(dplyr::select(age_effects,
                                 age_from = age,
                                 infectiousness),
                   by = "age_from") %>%
  dplyr::left_join(dplyr::select(age_effects,
                                 age_to = age,
                                 davies_updated),
                   by = "age_to") %>%
  # aggregate them to the required age ranges
  dplyr::mutate(
    age_group_to = cut(pmax(0.1, age_to), age_breaks, right = FALSE),
    age_group_from = cut(pmax(0.1, age_from), age_breaks, right = FALSE),
    .after = setting
  ) %>%
  dplyr::group_by(setting,
                  age_group_from,
                  age_group_to) %>%
  dplyr::summarise(across(c(infectiousness, davies_updated),
                          mean),
                   .groups =  "drop") 

agg_infectiousness_suscpetibility
```

We then estimate the relative transmissibility in household vs non-household settings and use the `setting_weights` which hold the weights given to each setting regarding transmissibility to scale the probability linearly for non-household transmission and binomially for household transmission so that onward infections do not to exceed the number of other household members.

```{r}
agg_infectiousness_suscpetibility%>%
    dplyr::left_join(
      setting_weights_tibble,
      by = "setting"
    ) %>%
    dplyr::mutate(
      relative_probability = infectiousness * davies_updated,
      probability = dplyr::case_when(
        setting == "home" ~ 1 - (1 - relative_probability) ^ weight,
        TRUE ~ relative_probability * weight
      )
    ) %>%
    dplyr::select(
      setting,
      age_group_from,
      age_group_to,
      probability
    )
  
```


Finally, the dataframe with the setting and age group specific relative per-contact transmission probability is converted to matrix format. 

#### generate_ngm
DONE
Once infected, a person can transmit an infectious disease to another, creating generations of infected individuals. One can define a matrix that conveys the number of newly infected individuals in given categories, such as age, for consecutive generations. This matrix is called a next generation matrix (NGM) (Diekmann et al (2010)).

The next generation matrix can be used to calculate the expected number of secondary infections in a given age group.

Given certain age breaks and the desired region, conmat computes the unscaled next generation matrices for that location across different settings & age groups using the contact rates extrapolated from polymod survey data on the specified location, adjusted by the per capita household size and the setting-specific relative per-contact transmission probability matrices for the same age groups. These NGMs are then scaled according to a target reproduction number (which is provided as an argument) using the ratio of the desired $R_0$ and the  $R_0$ of the NGM for the combination of all settings. The $R_0$ of the combination of all settings is obtained by calculating the unique, positive eigen value of the combination NGM. This ratio is then used to scale all the setting specific NGMs. 

> More notes on why scale as per the target reproduction number ?


#### apply_vaccination
DONE 
By improving a person's immunity from a disease, vaccination has consistently demonstrated to be one of the most effective strategies in the management and prevention of an infectious disease outbreak. When a sizable section of the population receives vaccinations or when vaccine coverage is sufficient enough, the likelihood that the unvaccinated population will contract the disease is decreased. This helps to slow infectious disease spread as well as lessen its severity. For this reason, it is important to understand how much of a reduction in probability of acquisition (the likelihood that an individual will contract the disease), and probability of transmission (the likelihood that an individual will spread the disease after contracting it), has occurred as an the effect of vaccination, in other words the effect of vaccination on the next generation of infections.

Conmat applies vaccination effects to next generation matrices using the function `apply_vaccination` that leads to reduction of acquisition and transmission in each age group in the next generation matrices. `apply_vaccination` takes two main arguments: (1) the next generation matrices of specified age groups (from `generate_ngm()`), and (2) data containing vaccine coverage, acquisition, and transmission (probabilities?) for each age groups, corresponding to given next generation matrices.

`apply_vaccination` returns the percentage reduction in acquisition and transmission in each age group. It does this by taking the outer product of these reductions in acquisition and transmission by age group, creating a transmission reduction matrix. The next generation matrices with the vaccination effects applied are then produced using the obtained transmission reduction matrix and the next generation matrices passed to the function as an argument.