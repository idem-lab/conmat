---
title: "understanding-conmat"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{understanding-conmat}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(conmat)
```

The goal of this vignette is to unpack the functions used in conmat, specifically:

- `extrapolate_polymod()`
- `fit_single_contact_model()`
- `fit_setting_contacts()`

By the end of this vignette, you should know...

# Some history

`conmat` was initially designed to predict the expected number of social contacts between age groups. In order to do this, we needed the following:

- Data describing the number of contacts between people
- A model that takes in input on the age population data, and predicts the number of contacts

We found data that describes the number of contacts between people in the POLYMOD survey, across different settings (home, work, school, other). The data looks like this:

```{r}
example_contact <- get_polymod_contact_data(setting = "home")
example_contact
library(dplyr)
example_contact_20 <- example_contact %>%
 filter(
   age_to <= 20,
   age_from <= 20
 )

example_contact_20
```

(note that we've trimmed down the max number of years so we can get a smaller dataset that we can model much faster).

Each row represents the average number of contacts between age groups in a setting, and the number of participants in that survey. So the first row shows that in a home setting, people aged 0 had an average number of 10 contacts with another person aged 0, and there were 92 participants.

We then need to build a model to predict the number of contacts. We decide to use a GAM to do this, as it allows for more flexible modelling options. Instead of predicting out `contacts ~ age_from + age_to`, we decided to use various combinations of `age_from` and `age_to`, which facilitate capturing various contact patterns.

The model effectively looks like this:

```{r}
contact_model <- mgcv::bam(
      formula = contacts ~
      # s(gam_age_offdiag) +
      abs(age_from - age_to) + 
      # s(gam_age_offdiag_2) +
      abs(age_from - age_to)^2 + 
      # s(gam_age_diag_prod) +
      abs(age_from * age_to) + 
      # s(gam_age_diag_sum) +
      abs(age_from + age_to) + 
      # s(gam_age_pmax) +
      pmax(age_from, age_to) + 
      # s(gam_age_pmin) ,
      pmin(age_from, age_to),
      family = stats::poisson,
      # NOTE: the offset of participants allows us to get the rate per person
      offset = log(participants),
      data = example_contact_20
    )

contact_model
```

Note that we are using as offset term in the model. This allows us to get the rate per person.

To unpack this, let's take a slightly different example model to explain the concept of using an offset to get the rate per person. Our model predicting the number of counts could be written as a poisson:

$$
n_{contacts} \sim Poisson(\lambda)
$$
With lambda given by an intercept ($\beta_0$) and coefficient ($\beta_1$)

$$
log(\lambda) = \beta_0 + \beta_1x
$$

We can get the rate ($\lambda$) per person by dividing $\lambda$ by the number of people ($N$:

$$
log(\frac{\lambda}{N}) = \beta_0 + \beta_1x
$$

Because we are using `log`, we can re-write that as:

$$
log(\lambda) - log(N) = \beta_0 + \beta_1x
$$

And by adding $log(N)$ to both sides we get:

$$
log(\lambda) = log(N) + \beta_0 + \beta_1x 
$$

This offset doesn't get estimated, rather it's simply added in the model.

Now, we wrap up that model fitting code above into a function `fit_single_contact_model`:

```{r}
example_population <- get_polymod_population()
example_population

my_mod <- fit_single_contact_model(
 contact_data = example_contact_20,
 population = example_population
)
```

Note here that we include some `population` data. The reason for this is to allow for different sized offsets for different types of setting data.

Currently we are just fitting an entire model to home settings, but we actually want to fit separate models for each setting. We could get each dataset, and then fit each model, like so:

```{r}
example_contact_home <- get_polymod_contact_data(setting = "home")
example_contact_work <- get_polymod_contact_data(setting = "work")
example_contact_school <- get_polymod_contact_data(setting = "school")
example_contact_other <- get_polymod_contact_data(setting = "other")

example_contact_home_20 <- example_contact_home |> 
  filter(age_to <= 20,
         age_from <= 20)
example_contact_work_20 <- example_contact_work |> 
  filter(age_to <= 20,
         age_from <= 20)
example_contact_school_20 <- example_contact_school |> 
  filter(age_to <= 20,
         age_from <= 20)
example_contact_other_20 <- example_contact_other |> 
  filter(age_to <= 20,
         age_from <= 20)

example_contact_home_20
example_contact_work_20
example_contact_school_20
example_contact_other_20
```


```{r}
my_mod_home <- fit_single_contact_model(
 contact_data = example_contact_home_20,
 population = example_population
)
my_mod_work <- fit_single_contact_model(
 contact_data = example_contact_work_20,
 population = example_population
)
my_mod_school <- fit_single_contact_model(
 contact_data = example_contact_school_20,
 population = example_population
)
my_mod_other <- fit_single_contact_model(
 contact_data = example_contact_other_20,
 population = example_population
)

my_mod_home
my_mod_work
my_mod_school
my_mod_other
```

But this is a bit of repetition! To save ourselves from this, we can get all the setting data with `get_polymod_setting_data()`, which returns a special summary print method, to save printing out a big list of data to the console:

```{r}
example_setting_data <- get_polymod_setting_data()

example_setting_data
```

We could then trim down the years here like so

```{r}
library(purrr)
example_setting_data_20 <- map(
  .x = example_setting_data,
  .f = \(x) filter(x, age_to <= 20, age_from <= 20)
) |> new_setting_data()
  
example_setting_data_20
```

And now instead of fitting the model separately several times ourselves like this:

```{r}
my_mod_home <- fit_single_contact_model(
 contact_data = example_setting_data_20$home,
 population = example_population
)
my_mod_work <- fit_single_contact_model(
 contact_data = example_setting_data_20$work,
 population = example_population
)
my_mod_school <- fit_single_contact_model(
 contact_data = example_setting_data_20$school,
 population = example_population
)
my_mod_other <- fit_single_contact_model(
 contact_data = example_setting_data_20$other,
 population = example_population
)
```

We can fit all the models like so:

```{r}
my_mod_all_settings <- fit_setting_contacts(
  contact_data_list = example_setting_data_20,
  population = example_population
)
my_mod_all_settings
```


Essentially we needed age population information to help create better offsets for school and work, but we don't need to worry about that at the moment.
